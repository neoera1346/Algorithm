// ! 문제:
/*
정수를 요소로 갖는 배열을 입력받아 오름차순으로 정렬하여 리턴해야 합니다.
버블 정렬(bubble sort)은 여러 정렬 알고리즘(삽입 정렬, 퀵 정렬, 병합 정렬, 기수 정렬 등) 중 가장 기본적인 알고리즘입니다.

버블 정렬 알고리즘은 아래와 같습니다.

첫 번째 요소가 두 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)
두 번째 요소와 세 번째 요소보다 크면, 두 요소의 위치를 바꿉니다. (swap)
1, 2를 마지막까지 반복합니다. (마지막에서 두 번째 요소와 마지막 요소를 비교)
1~3의 과정을 한 번 거치게 되면, 가장 큰 요소가 배열의 마지막으로 밀려납니다.
1~3의 과정을 첫 요소부터 다시 반복합니다.
5를 통해 두 번째로 큰 요소가 배열의 마지막 바로 두 번째로 밀려납니다.
1~3의 과정을 총 n번(배열의 크기) 반복합니다.
이 모습이 마치 '거품이 밀려 올라가는 것과 같은 모습'과 같아서 bubble sort라고 부릅니다.
*/

// ! 주의사항: 
/*
위에서 설명한 알고리즘을 구현해야 합니다.
arr.sort 사용은 금지됩니다.
입력으로 주어진 배열은 중첩되지 않은 1차원 배열입니다.

아래의 힌트를 바탕으로 (최선의 경우) 수행 시간을 단축할 수 있도록 코드를 수정해보세요.
위에서 설명된 알고리즘 1~3의 과정 중 어떤 요소도 위치가 바뀌지 않은 경우, 배열이 정렬된 상태라는 것을 알 수 있습니다.
*/

// ! 입출력 예시:
/*
let output = bubbleSort([2, 1, 3]);
console.log(output); // --> [1, 2, 3]
*/

// ! 내 접근 방법:
// ? 1. 수행 시간을 단축시키기 위해 함수를 두개로 쪼갠다.
// ? 2. 작은 단위 함수에서는 Destructuring assignments를 활용해 두 요소의 위치를 바꿔준다.
// ? 2 - 1. (arr이 reference type이라 가능하다.)
// ? 3. 큰 단위 함수에서는 두 요소 위치가 바뀌는 횟수를 기록해준다.
// ? 4. 어떤 요소도 swap되지 않은 경우, 배열은 정렬된 상태이다.
// ? 5. 매 반복(iteration)마다 i번째로 큰 수가 마지막에서 i번째 위치하게 된다.
// ? 6. 이미 정렬된 요소는 고려할 필요가 없으므로, 'j < n - 1 - i'만 비교하면 된다.

// ! 내가 푼 방법 (1)
const swap = function(idx1, idx2, arr) {
    [arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}

const bubbleSort = function(arr) {
    let n = arr.length;

    for (let i = 0; i < n; i++) {
        let swaps = 0;

        for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(j, j + 1, arr);
                swaps++; // [2, 1, 3, 4, 5]
            }
        }

        if (swaps === 0) {
            break;
        }
    }

    return arr
        // TODO: 여기에 코드를 작성합니다.
};

// =======================================================================================

// ! 추가 노트
// ? 1. swap을 통해 횟수를 설정/기록한 이유는 무엇인가.
/* 
버블 정렬은 인접한 두 인덱스의 요소를 비교하여, 위치를 바꿔야 할 필요가 있는 경우 두 요소의 위치를 바꾸게 됩니다.
이미 정렬된 경우에는 위치의 변경이 일어나질 않겠죠?

단 한번의 순회 때, 변경이 한 번도 일어나지 않아, 현재의 상태가 변경이 불필요한, 즉 이미 정렬된 상태임을 알 수 있습니다.
[1, 2, 3, 4, 5, 6, 7]
따라서 정렬의 목적이 완성되었기 때문에 더 이상의 O(N^2) 순회가 필요하지 않게 됩니다.

비슷한 논리로 아래와 같은 배열을 고려해 봅시다.
[7, 1, 2, 3, 4, 5, 6]

한 번의 순회(j === 0)로 배열은 어떤 상태에 도달하게 될까요?
6번의 교환이 일어납니다. 교환이 한번이라도 일어났다는 의미는 현재 배열이 정렬되지 않았다는 것을 의미합니다.
따라서 정렬 작업을 계속 이어나가야 합니다. 이게 몇번이 더 될지는 모르는 일입니다.

1) 한 번의 순회를 얻을 수 있는 배열의 상태
초기 배열이 [7, 1, 2, 3, 4, 5, 6]인 경우, [1, 2, 3, 4, 5, 6, 7]
초기 배열이 [6, 1, 2, 7, 3, 4, 5,]인 경우, [1, 2, 3, 4, 5, 6, 7]
각각의 배열은 교환(swap)이 발생한 상태입니다. 따라서 정렬 작업을 이어나가야 합니다.
두 번째 순회(j === 1)에서 [1, 2, 3, 4, 5, 6, 7] 은 단 한번의 교환도 발생하지 않습니다. 따라서 세 번째 순회(j === 2)가 필요하지 않습니다.
*/

// ? 2. 반복문 안에서 범위를 j < N - 1 - i;처럼 길이에서 1 - i를 한 이유는 무엇인가.
/*
버블 정렬은 인접한 두 인덱스의 요소를 비교하여, 위치를 바꿔야 할 필요가 있는 경우 두 요소의 위치를 바꾸게 됩니다.

오름차순 기준으로 설명하면,

0과 1 두 인덱스의 비교를 하고 (이 때 두 요소 중 더 큰 요소가 인덱스 1에 위치하게 됩니다.)
다음으로 1과 2 두 인덱스를 비교합니다. (바로 전단계에서 더 큰 요소가 인덱스 1에 위치하게 됩니다. 마찬가지로 1과 2에 위치한 요소 중 더 큰 요소가 인덱스 2에 위치하게 됩니다)
이런 식으로 마지막 인덱스까지 비교를 하게 됩니다.
그럼 마지막 인덱스에는 가장 큰 요소가 위치하게 되겠죠???

그럼 한번의 순회(loop)로 [정렬되지 않았을 수도 있는 부분 배열] + 마지막 하나의 요소 를 얻게 됩니다.
(여기서 정렬되지 않았을 수도 있는 부분 배열이라고 표현한 이유를 아시겠나요??)
다음 순회를 할 때는 [정렬되지 않았을 수도 있는 부분 배열] 중에서 가장 큰 요소만 알면 되는 것이죠.
따라서 전 순회에서 얻은 가장 큰 요소를 고려할 필요가 없어지게 됩니다.

i가 0일 때는 0, 1 / 1, 2 / 2, 3/ ... / n-2, n-1 을 비교하면 됩니다.
즉 처음부터 j < N 이 아니라 j < N - 1 입니다.
그리고 0일 때는 N-1까지 비교를 하고, 1일 때는 (한개가 줄어든) N-2까지 비교를 하고 싶습니다.
그래서 j < N - 1- i가 됩니다.
*/

// ? 3. swap 함수의 다른 작성 방법
// 1) 임시 변수를 활용한 방법
// let temp = arr[idx1];
// arr[idx1] = arr[idx2];
// arr[idx2] = temp;

// 2) XOR 연산을 활용한 방법
// arr이 reference type이라 가능
// arr[idx1] ^= arr[idx2];
// arr[idx2] ^= arr[idx1];
// arr[idx1] ^= arr[idx2];